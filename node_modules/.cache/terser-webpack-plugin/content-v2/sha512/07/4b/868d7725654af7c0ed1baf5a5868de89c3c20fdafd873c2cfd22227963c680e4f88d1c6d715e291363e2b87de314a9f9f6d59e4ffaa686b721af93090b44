{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{180:function(t,e,a){\"use strict\";a.r(e);var r=a(0),i=Object(r.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a(\"div\",{staticClass:\"content\"},[t._m(0),t._v(\" \"),t._m(1),t._v(\" \"),a(\"p\",[t._v('三种方式得到Class：getClass()、类名.class、Class.forName(\"\")')]),t._v(\" \"),t._m(2),t._v(\" \"),a(\"p\",[t._v(\"hashmap继承abstractMap<K,V>，线程不安全,key允许为null,value允许为null。get(object key)方法若返回null，可能是key不存在为null，也可能是key对应的value为null，所以不能通过get方法判断键是否存在，要使用containsKey\")]),t._v(\" \"),a(\"p\",[t._v(\"hashtable继承Dictionary<K,V>,很多方法加了synchronized，所以是线程安全的。key和value都不允许为null，\\nvalue为null抛出nullpointexception\")]),t._v(\" \"),t._m(3),t._v(\" \"),t._m(4),t._v(\" \"),t._m(5),t._v(\" \"),a(\"p\",[t._v(\"SE：standard edition\\nEE：enterprise edition\\nME：micro edition\\n框架：Struts、Spring、Hibernate、spring mvc，spring boot, spring cloud、mybatis\")]),t._v(\" \"),t._m(6),t._v(\" \"),t._m(7),t._v(\" \"),a(\"p\",[t._v(\"​\\t原理：提交一个任务到线程池中，流程如下\")]),t._v(\" \"),a(\"p\",[t._v(\"​\\t\\t第一步：先判断线程池的核心线程是否都在执行任务，若不满，则创建，若核心线程都在执行任务，看第二步\\n​\\t\\t第二步：线程池判断工作队列是否已满，若没有满，则将新提交的存储在工作队列里，若满了，看第三步\\n​\\t\\t第三步：判断线程池里的线程是否都处于工作状态，若没有，则创建新工作线程执行任务，若满了，交给饱和策略来进行处理\\n​\\t线程是稀缺资源，被无限制的创建，不仅消耗系统资源还会降低系统稳定性。所以要创建线程池\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"创建线程池核心参数\")]),t._v(\"\\nLinkedBlockingDeque queque = new LinkedBlockingDeque\"),a(\"Runnable\",[t._v(\"(3);\\nRejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy();//饱和策略\\nnew ThreadPoolExecutor(2,10,60, TimeUnit.SECONDS,queque,handler);//核心线程数2个，全部线程数10个，工作队列3个\\ncorePoolSize：核心线程数，当提交任务，线程池创建新线程执行任务直到当前线程数等于corePoolSize\\nmaximumPoolSize：线程池中允许的最大线程数，若当前阻塞队列满了，继续提交任务，创建新的线程执行任务，前提是小于maximum\\nkeepAliveTime：线程空闲时的存活时间\\nunit：keepaliveTime的单位\\nworkQueue：用来保存等待被执行的任务的阻塞队列，且实现runnable接口\")])],1),t._v(\" \"),t._m(8),t._v(\" \"),a(\"p\",[t._v(\"周期：NEW(新建)、RUNNABLE（就绪）、RUNNING（运行）、BLOCKED（阻塞）、DEAD（死亡）\\n僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中\")]),t._v(\" \"),t._m(9),t._v(\" \"),a(\"p\",[t._v(\"实现线程安全的方式有：同步代码块、同步方法、加lock锁机制\\nwait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会释放对象锁。\")]),t._v(\" \"),t._m(10),t._v(\" \"),a(\"p\",[t._v(\"synchronized锁粒度、模拟死锁场景、原子性与可见性；\\nvolatile强制线程每次从主内存中读到变量，而不是从线程的私有内存中读取变量，保证数据的可见性\\nvolatile轻量级，只修饰变量，不能同步\\nsynchronized重量级，可以用来修饰方法，保证可见性和原子性\")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e(\"h1\",{attrs:{id:\"java基础知识\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java基础知识\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" java基础知识\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"h2\",{attrs:{id:\"java反射\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java反射\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" java反射\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"h2\",{attrs:{id:\"hashmap和hashtable区别\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hashmap和hashtable区别\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" hashmap和hashtable区别\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"h2\",{attrs:{id:\"string-stringbuffer、stringbuilder区别\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#string-stringbuffer、stringbuilder区别\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" String Stringbuffer、stringbuilder区别\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"p\",[e(\"strong\",[this._v(\"主要在运行速度和线程安全方面的区别\")]),this._v(\"\\n运行速度：stringbuilder > stringbuffer > string\\nStringbuffer和stringbuilder继承abstractstringbuilder抽象类\\nstring：字符串常量，一旦创建则该对象不可更改，如果不断的进行创建、回收对象，则速度会变慢\\nStringbuffer：线程安全，其中的append方法使用了synchoronized，导致效率比stringbuilder低\\nstringbuilder：非线程安全，效率高于stringbuffer\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"h2\",{attrs:{id:\"java-se、ee、me及框架\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java-se、ee、me及框架\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" java SE、EE、ME及框架\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"h2\",{attrs:{id:\"java多线程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java多线程\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" Java多线程\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"h3\",{attrs:{id:\"线程池\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程池\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" 线程池\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"h3\",{attrs:{id:\"线程的生命周期\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程的生命周期\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" 线程的生命周期\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"h3\",{attrs:{id:\"线程安全\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程安全\",\"aria-hidden\":\"true\"}},[this._v(\"#\")]),this._v(\" 线程安全\")])},function(){var t=this.$createElement,e=this._self._c||t;return e(\"p\",[e(\"strong\",[this._v(\"synchronized、volatile区别\")])])}],!1,null,null,null);e.default=i.exports}}]);","extractedComments":[]}