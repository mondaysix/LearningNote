{"remainingRequest":"C:\\Users\\ZO\\Desktop\\LearningNote\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!C:\\Users\\ZO\\Desktop\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!C:\\Users\\ZO\\Desktop\\LearningNote\\docs\\java\\Syntax.md?vue&type=template&id=5f48a3aa&","dependencies":[{"path":"C:\\Users\\ZO\\Desktop\\LearningNote\\docs\\java\\Syntax.md","mtime":1558840161145},{"path":"C:\\Users\\ZO\\Desktop\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\ZO\\Desktop\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"C:\\Users\\ZO\\Desktop\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\ZO\\Desktop\\LearningNote\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\ZO\\Desktop\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"java基础知识\"><a class=\"header-anchor\" href=\"#java基础知识\" aria-hidden=\"true\">#</a> java基础知识</h1>\n<h2 id=\"java反射\"><a class=\"header-anchor\" href=\"#java反射\" aria-hidden=\"true\">#</a> java反射</h2>\n<p>三种方式得到Class：getClass()、类名.class、Class.forName(&quot;&quot;)</p>\n<h2 id=\"hashmap和hashtable区别\"><a class=\"header-anchor\" href=\"#hashmap和hashtable区别\" aria-hidden=\"true\">#</a> hashmap和hashtable区别</h2>\n<p>hashmap继承abstractMap&lt;K,V&gt;，线程不安全,key允许为null,value允许为null。get(object key)方法若返回null，可能是key不存在为null，也可能是key对应的value为null，所以不能通过get方法判断键是否存在，要使用containsKey</p>\n<p>hashtable继承Dictionary&lt;K,V&gt;,很多方法加了synchronized，所以是线程安全的。key和value都不允许为null，\nvalue为null抛出nullpointexception</p>\n<h2 id=\"string-stringbuffer、stringbuilder区别\"><a class=\"header-anchor\" href=\"#string-stringbuffer、stringbuilder区别\" aria-hidden=\"true\">#</a> String Stringbuffer、stringbuilder区别</h2>\n<p><strong>主要在运行速度和线程安全方面的区别</strong>\n运行速度：stringbuilder &gt; stringbuffer &gt; string\nStringbuffer和stringbuilder继承abstractstringbuilder抽象类\nstring：字符串常量，一旦创建则该对象不可更改，如果不断的进行创建、回收对象，则速度会变慢\nStringbuffer：线程安全，其中的append方法使用了synchoronized，导致效率比stringbuilder低\nstringbuilder：非线程安全，效率高于stringbuffer</p>\n<h2 id=\"java-se、ee、me及框架\"><a class=\"header-anchor\" href=\"#java-se、ee、me及框架\" aria-hidden=\"true\">#</a> java SE、EE、ME及框架</h2>\n<p>SE：standard edition\nEE：enterprise edition\nME：micro edition\n框架：Struts、Spring、Hibernate、spring mvc，spring boot, spring cloud、mybatis</p>\n<h2 id=\"java多线程\"><a class=\"header-anchor\" href=\"#java多线程\" aria-hidden=\"true\">#</a> Java多线程</h2>\n<p>线程池</p>\n<p>​\t原理：提交一个任务到线程池中，流程如下</p>\n<p>​\t\t第一步：先判断线程池的核心线程是否都在执行任务，若不满，则创建，若核心线程都在执行任务，看第二步\n​\t\t第二步：线程池判断工作队列是否已满，若没有满，则将新提交的存储在工作队列里，若满了，看第三步\n​\t\t第三步：判断线程池里的线程是否都处于工作状态，若没有，则创建新工作线程执行任务，若满了，交给饱和策略来进行处理\n​\t线程是稀缺资源，被无限制的创建，不仅消耗系统资源还会降低系统稳定性。所以要创建线程池</p>\n<p><strong>创建线程池核心参数</strong></p>\n<!--beforebegin--><div class=\"language-java extra-class\"><!--afterbegin--><pre v-pre class=\"language-java\"><code><span class=\"token class-name\">LinkedBlockingDeque</span> queque <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingDeque</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">RejectedExecutionHandler</span> handler <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">DiscardPolicy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//饱和策略</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">60</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">,</span>queque<span class=\"token punctuation\">,</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//核心线程数2个，全部线程数10个，工作队列3个</span>\ncorePoolSize：核心线程数，当提交任务，线程池创建新线程执行任务直到当前线程数等于corePoolSize\nmaximumPoolSize：线程池中允许的最大线程数，若当前阻塞队列满了，继续提交任务，创建新的线程执行任务，前提是小于maximum\nkeepAliveTime：线程空闲时的存活时间\nunit：keepaliveTime的单位\nworkQueue：用来保存等待被执行的任务的阻塞队列，且实现runnable接口\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"线程的生命周期\"><a class=\"header-anchor\" href=\"#线程的生命周期\" aria-hidden=\"true\">#</a> 线程的生命周期</h3>\n<p>周期：NEW(新建)、RUNNABLE（就绪）、RUNNING（运行）、BLOCKED（阻塞）、DEAD（死亡）\n僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中</p>\n<h3 id=\"线程安全\"><a class=\"header-anchor\" href=\"#线程安全\" aria-hidden=\"true\">#</a> 线程安全</h3>\n<p>实现线程安全的方式有：同步代码块、同步方法、加lock锁机制\nwait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会释放对象锁。</p>\n<p><strong>synchronized、volatile区别</strong></p>\n<p>synchronized锁粒度、模拟死锁场景、原子性与可见性；\nvolatile强制线程每次从主内存中读到变量，而不是从线程的私有内存中读取变量，保证数据的可见性\nvolatile轻量级，只修饰变量，不能同步\nsynchronized重量级，可以用来修饰方法，保证可见性和原子性</p>\n</div>\n",null]}