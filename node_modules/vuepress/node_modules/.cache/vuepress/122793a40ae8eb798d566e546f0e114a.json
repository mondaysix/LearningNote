{"remainingRequest":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!G:\\code\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!G:\\code\\LearningNote\\docs\\swtest\\test-selenium.md?vue&type=template&id=6865c6f2&","dependencies":[{"path":"G:\\code\\LearningNote\\docs\\swtest\\test-selenium.md","mtime":1559051174485},{"path":"G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"selenium实现web自动化\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#selenium实现web自动化\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Selenium实现web自动化\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"selenium-1-0工作原理\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#selenium-1-0工作原理\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Selenium 1.0工作原理\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"​\\t1.0又称Selenium Remote Control,利用的原理是：javascript代码可以很方便的获取页面上的任何元素并执行各种操作。（基于javascript代码注入）\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"​\\t“同源策略”：只有来自相同域名、端口和协议的javascript代码才能被浏览器执行。所以selenium RC就必须欺骗被测站点，则需要引入selenium RC Server\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"​\\tRC 包括两个部分 RC Server 、Client Libraries。RC Server包括Launcher、Http Proxy、Selenium Core。Client Libraries包括Java、c#、Ruby等等\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"​\\tSelenium Core:被注入到浏览器页面中javascript函数集合，用来实现页面元素的识别和操作\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"​\\tHttp Proxy：代理服务器，以达到欺骗被测站点目的\")]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"​\\tLauncher：在启动测试浏览器时完成selenium core的注入和浏览器代理的设置\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"​\\tClient Libraries:测试大爱吗向selenium rc server发送http请求的接口\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"Selenium RC的执行流程如下：\")]),\n      _vm._v(\" \"),\n      _c(\"ol\", [\n        _c(\"li\", [\n          _vm._v(\n            \"测试用例基于不同语言编写的Client Libraries向RC Server发送请求，要求建立连接\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"建立连接后，Launcher启动浏览器，把selenium core加载到浏览器页面并把浏览器代理设置为Http Proxy\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"测试用例向RC server发送http请求，RC server解析请求，通过http proxy发送javascript命令通知core执行浏览器上控件的具体操作\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"selenium core接收到指令后执行操作\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"若浏览器接收到新的页面请求，则发送请求新的页面，launcher启动浏览器时有代理，则rc server会接收到所有由它启动的浏览器发送的请求\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"rc server 接收到请求后，重组http请求规避同源策略，然后获取对应的web页面\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"http proxy把接收到的web页面返回给浏览器，\")])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"selenium-2-0工作原理\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#selenium-2-0工作原理\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Selenium 2.0工作原理\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"2.0又称selenium webdriver，利用的原理是使用浏览器原生的webdriver实现页面操作。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"webdriver是典型的server-client模式，执行流程如下：\")]),\n      _vm._v(\" \"),\n      _c(\"ol\", [\n        _c(\"li\", [\n          _vm._v(\n            \"client启动浏览器时，后台同时启动基于webdriver wire协议的web service作为remote server并与浏览器进行绑定，绑定后，remote server 开始监听client的请求\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"client将要执行的页面请求以http request的方式发送给remote server。http request的body是以webdriver wire协议规定的json格式来描述需要浏览器执行的具体操作\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"remote server接收到请求后，会请求解析，将解析结果发送给webdriver，由webdriver实际执行浏览器的操作\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"webdriver看作是直接操作浏览器的 原生组件，所以在测试前需要下载浏览器相应的webdriver\"\n          )\n        ])\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}