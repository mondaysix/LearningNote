{"remainingRequest":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!G:\\code\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!G:\\code\\LearningNote\\docs\\swtest\\test-gui.md?vue&type=template&id=7c2e0cca&","dependencies":[{"path":"G:\\code\\LearningNote\\docs\\swtest\\test-gui.md","mtime":1559565628917},{"path":"G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"gui测试\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#gui测试\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" GUI测试\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"gui自动化测试稳定性\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#gui自动化测试稳定性\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" GUI自动化测试稳定性\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"表现为同样的测试用例在同样的环境上，时而测试通过，时而测试失败，严重降低了GUI测试的可信性\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_c(\"strong\", [_vm._v(\"GUI测试不稳定的因素\")]), _vm._v(\"：\")]),\n      _vm._v(\" \"),\n      _c(\"ol\", [\n        _c(\"li\", [_vm._v(\"非预计的弹出对话框\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"页面控件属性的细微变化\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"被测系统的A/B测试\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"随机的页面延迟造成控件识别失败\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"测试数据问题\")])\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [\n        _c(\"p\", [_vm._v(\"非预计的弹出对话框，一般包含两种场景：\")])\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"GUI自动化测试用例执行过程中，操作系统弹出的非预计对话框，比如弹出杀毒软件更新请求、病毒报告、系统更新请求等等\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"被测软件本身在非预期的时间弹出预期的对话框，比如在网站进行操作时，随机弹出用户调查对话框\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"那么怎么解决呢，在手工测试时，会直接点击关闭对话框，然后再继续业务测试操作，对自动化脚本来说也是同样的道理，一般可以这样做：\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"当自动化脚本发现控件无法正常定位时或者无法继续操作，GUI自动化框架自动进入“异常场景恢复测试”，GUI自动化框架依次检查各种可能出现的对话框，一旦确认了对话框的类型，立即执行预定义的操作，接着重试刚才执行到的失败步骤。这种方式只能处理已知可能会出现的对话框，对于新类型的对话框，只能通过自动化的方式尝试点击上面的按钮进行处理。每当发现一种潜在会弹出的对话框，就把它更新到“异常场景”库中\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [_c(\"p\", [_vm._v(\"页面控件属性的细微变化\")])]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"如果页面控件的属性发生了变化，也会导致测试脚本的定位元素失败\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"比如控件的id发生了变化，一般可以这样处理：\")]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"通过控件的类型缩小范围，属性值的关键字再进一步缩小范围，或者根据属性变化前后的相似度\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [_c(\"p\", [_vm._v(\"被测系统的A/B测试\")])]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"A/B测试，通常为web或者app的界面或者流程提供两种不同的版本，然后让用户随机访问其中的一个版本，并收集两个版本的用户体验数据和业务数据，最后分析评估出最好的版本用于正式发布\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"A/B测试通常会发布到实际生产环境，所以会造成不稳定性，一般解决思路：\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"在测试脚本内部对不同的被测版本做分支处理，脚本能区分a和b两个版本并作出相应的处理\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [_c(\"p\", [_vm._v(\"随机的页面延迟造成控件识别失败\")])]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"加入重试机制，当某一步GUI操作失败时，框架会自动发起重试，往往重试方式不是测试框架自带的功能，需要进行二次开发来实现\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [_c(\"p\", [_vm._v(\"测试数据问题\")])]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"测试用例所依赖的数据被其他用例修改了，或者在测试过程中发生错误后自动进行了重试操作，但数据状态已经在第一次执行中被修改了。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"页面对象自动生成技术\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#页面对象自动生成技术\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 页面对象自动生成技术\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"页面对象模型是以WEB页面为单位来封装页面上的控件以及控件的部分操作，而测试用例基于页面对象完成具体操作，最典型的模式就是：XXXPage.YYYComponent.ZZZOperation\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"适用于需要维护大量页面对象的中大型GUI自动化测试项目\")]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"页面对象自动生成技术，属于典型的“自动化你的自动化”的应用场景，基本思路是，不用手动维护page class，只需要提供web的url，自动生成这个页面上所有的控件的定位信息，并自动生成page class\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"Katalon Studio工具已经提供了类似的页面对象库管理功能\")]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"测试数据自动生成，指由机器自动生成测试用例的输入数据。局限于两种情况：根据GUI输入数据类型以及对应的自定义规则库自动生成测试输入数据；对于需要组合多个测试输入数据的场景，测试数据自动生成可以完成多个测试数据的笛卡尔积，然后以人工的方式剔除掉非法的数据组合\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"无头浏览器（Headless Browser）是一种没有界面的浏览器。主要应用场景：GUI自动化测试、页面监控、网络爬虫。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"主要的优势有：测试执行速度更快，无需加载css以及渲染页面；减少对测试执行的干扰，可以减少操作系统以及其他软件不可预期的弹出框，对浏览器测试的干扰；简化测试执行环境的搭建，对于大量的测试用例的执行而言，减少对大规模selenium grid集群的依赖；在单机环境实现测试的并发执行。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"主要的缺点有：不能完全模拟真实的用户行为，不适用于需要对于页面布局进行验证的场景。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"在Google发布Headless Chrome之前，PhantomJS是主流的无头浏览器解决方案。Headless chrome+Puppeteer框架成为无头浏览器的首选方案。Pupperteer是一个node库，提供高级别的API封装\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"gui自动化测试报告\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#gui自动化测试报告\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" GUI自动化测试报告\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"早期出现基于视频的GUI测试报告，也就是GUI自动化测试框架对测试执行整个过程进行屏幕录像并生成视频。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"理想中的GUI测试报告应该是由一系列按时间顺序排列的屏幕截图组成，并且这些截图上可以高亮显示所操作的元素，同时配有相关操作步骤的详细描述\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"使用开源GUI测试框架，比如Selenium Webdriver，需要自实现截图以及高亮显示操作元素的功能，具体到代码的实现，通常两种方式：扩展Selenium原本的操作函数、在相关的hook操作中调用screenshot函数\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_c(\"strong\", [_vm._v(\"扩展Selenium原本的操作函数\")])]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"selenium原生的click操作并不具备截图以及高亮，那么自己封装新的click，可以先用js代码高亮（对象的边框上渲染一个5-8个像素的边缘）显示被操作元素，再调用screenshot完成截图，最后调用原生的click函数完成点击\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_c(\"strong\", [_vm._v(\"在相关的hook操作中调用screenshot函数\")])]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"当执行某个函数F时，系统会在执行函数F前隐式执行一个空实现的函数，那当需要做一些扩展或者拦截时，就可以在这样的空实现的函数中加入自定义的操作，像这样的空实现的函数就是hook函数\"\n        )\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}