{"remainingRequest":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!G:\\code\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!G:\\code\\LearningNote\\docs\\android\\appBase.md?vue&type=template&id=0aa574f0&","dependencies":[{"path":"G:\\code\\LearningNote\\docs\\android\\appBase.md","mtime":1559139013697},{"path":"G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"G:\\code\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"android-app基础知识\\\"><a href=\\\"#android-app基础知识\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Android APP基础知识</h1> <h2 id=\\\"activity\\\"><a href=\\\"#activity\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Activity</h2> <p><strong>生命周期</strong>：onCreate()--&gt;onStart()--&gt;onResume()--&gt;onPause()--&gt;onStop()---&gt;onRestart()--&gt;onDestroy()</p> <p>启动Activity：onCreate()--&gt;onStart()--&gt;onResume()然后Activity进入运行状态</p> <p>当前Activity被其他Activity覆盖,调用onPause()</p> <p>当前ACTIVITY回到前台，调用OnResume</p> <p><strong>启动模式</strong></p> <p>Standard（每次都会创建一个activity）、</p> <p>singleTop（栈顶复用）：若需要创建的activity处于栈顶，则直接复用，onNewIntent（传入新的intent）会被调用。如果没有处于栈顶则和standard模式一致</p> <p>singleTask(栈内复用)：若需要创建的activity处于栈内，则把存在他上面的所有activity都销毁</p> <p>singleInstance(全局单例模式)：整个系统中只有一个</p> <p>启动模式方式：</p> <p>​       manifest.xml中静态指定，launchMode</p> <pre><code>intent中动态指定：addFlags\\n</code></pre> <h2 id=\\\"service\\\"><a href=\\\"#service\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Service</h2> <p>启动方式：startservice和bindservice</p> <p>**startservice：**启动一个服务执行后台任务，不进行通信，停止服务使用stopservice</p> <p>生命周期：startservice—&gt;oncreate---&gt;onstartcommand---&gt;service running—&gt;ondestroy</p> <p>**bindservice:**启动服务可以进行通信，停止服务使用unbindservice</p> <p>生命周期：bindservice---》oncreate---》onbind---》client are bound to service---》onunbind---》ondestroy</p> <p>service需要注册在manifest</p> <p>两者的区别：startservice与客户端是否退出没有关联关系，即使客户端停止运行，服务同样也会在后台运行。bindservice是与客户端绑定的，客户端退出，service也自动停止</p> <h2 id=\\\"broadcastreceiver\\\"><a href=\\\"#broadcastreceiver\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> BroadcastReceiver</h2> <p>静态注册和动态注册</p> <h2 id=\\\"contentprovider\\\"><a href=\\\"#contentprovider\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> ContentProvider</h2>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}