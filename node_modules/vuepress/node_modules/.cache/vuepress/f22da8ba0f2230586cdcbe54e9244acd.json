{"remainingRequest":"C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!C:\\Users\\Objec\\Desktop\\LearningNote\\docs\\swtest\\autotest.md?vue&type=template&id=94cdd16a&","dependencies":[{"path":"C:\\Users\\Objec\\Desktop\\LearningNote\\docs\\swtest\\autotest.md","mtime":1559711629830},{"path":"C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1559711637495},{"path":"C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1559711718187},{"path":"C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1559711637495},{"path":"C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\vue-loader\\lib\\index.js","mtime":1559711718171},{"path":"C:\\Users\\Objec\\Desktop\\LearningNote\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":1559711720027}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"浅谈自动化测试\\\"><a href=\\\"#浅谈自动化测试\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 浅谈自动化测试</h1> <h2 id=\\\"什么是自动化测试\\\"><a href=\\\"#什么是自动化测试\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 什么是自动化测试</h2> <p>自动化测试：人对软件的测试操作行为转化为机器执行测试行为的一种实践</p> <p>当自动化测试用例维护成本高于其节省的测试成本时，自动化测试就失去了价值与意义，那么自动化测试有什么优点呢？</p> <ol><li>替代大量的手工机械重复性操作，测试工程师可以把更多的精力放在设计测试用例和新的功能测试上</li> <li>提升回归测试的效率，适合敏捷开发过程</li> <li>适合非工作时间执行测试，在工作时间分析失败的测试用例结果</li> <li>可长时间持续的运行被测系统，进行压力测试，避免人为的遗漏和疏忽</li></ol> <p>自动化测试又有哪些缺陷呢？</p> <ol><li>并不能完全的替代手工测试，对于系统的变化，自动化测试用例的维护成本也是很高的，要是执行过程中出现意外事件，自动化测试也没有任何处理能力，它只是按照事先定义好的步骤执行验证</li> <li>手工测试发现的缺陷数量通常比自动化测试要更多，自动化只能发现回归测试范围内的缺陷</li> <li>测试的效率依赖于自动化测试用例的设计和实现的质量，不稳定的自动化更糟糕</li></ol> <h2 id=\\\"什么软件产品适合自动化测试\\\"><a href=\\\"#什么软件产品适合自动化测试\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 什么软件产品适合自动化测试</h2> <p>系统需求稳定，不会频繁变动的</p> <p>研发和维护周期长，需要频繁的进行回归测试</p> <p>需要在不同平台重复运行相同的测试的场景</p> <p>通过手工测试无法实现的或者手工成本太高的</p> <h2 id=\\\"软件不同开发阶段设计的自动化测试\\\"><a href=\\\"#软件不同开发阶段设计的自动化测试\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 软件不同开发阶段设计的自动化测试</h2> <ol><li><p>单元测试阶段</p> <p>用例框架代码自动生成</p> <p>部分测试数据自动生成</p> <p>自动桩代码生成</p> <p>被测代码的自动化静态分析，识别出违反编码规则或者编码风格的代码行</p> <p>自动统计测试覆盖率，比如代码行覆盖率、分支覆盖率，帮助衡量单元测试用例集合的充分性和完备性</p></li> <li><p>代码级集成测试</p> <p>对被测函数以不同的输入参数组合进行调用并验证结果，更多关注软件模块之间的接口调用和数据传递</p></li> <li><p>Web Service：soap api和rest api两类</p> <p>基于代码的API测试通常包括三步：准备api调用时需要的测试数据、准备API调用参数并发起API调用、验证API调用返回结果。</p></li> <li><p>GUI自动化测试</p> <p>基于页面元素识别技术，对页面元素进行自动化操作，模拟实际终端用户的行为并验证软件功能的正确性</p> <p>web浏览器自动化测试，主流采用开源的selenium。移动端原生应用，采用主流的Appium</p></li></ol>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}